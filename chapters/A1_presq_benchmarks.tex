The repository \texttt{MatchBox}\footnote{\url{https://github.com/ayllon/MatchBox/}}
contains the Python implementation of \PresQ and \Find used as a reference for the
performance comparison shown in chapter~\ref{chapter:presq}, together with instructions
to reproduce the results.

For facilitating the replicability of the results, the repository contains an \linebreak
\texttt{environment.yml} file that allows re-creating a working Python environment
with all the requirements installed using \href{https://docs.conda.io/en/latest/}{\texttt{Conda}}:

\begin{minted}{bash}
conda env create
conda activate matchbox
\end{minted}

\section{Bench-marking quasi-clique finding}

\texttt{benchmark-quasiclique.py} compares the performances of \Find (baseline) and \PresQ
when searching for a known quasi-clique generated randomly based on an initial parameterization:
rank, cardinality, the ratio of missing edges, the number of nodes not belonging to the
quasi-clique, and the ratio of spurious edges. The results are written to a \gls{CSV} file.

The script snippet~\ref{script:quasi_missing} shows the relevant extract used to evaluate
the capacity of \PresQ to recover from missing edges, as reported in figure~\ref{fig:3hyper_alpha}.

\begin{code}
\caption{Benchmark quasi-clique search with a set of missing ratios}\label{script:quasi_missing}
\begin{minted}{bash}
for alpha in 0.05 0.10 0.15 0.20 0.25 0.30; do
  ./bin/benchmark-quasiclique.py \
    --out "results/quasi3.csv" \ # Output CSV
    --rank 3 \                   # 3-hypergraph
    --cardinality 10 20 30 \     # Number of nodes on the quasi-clique
    --additional 0.5 \           # |V| * 0.5 additional nodes
    --repeat 15 \                # Generate 15 different hypergraphs
    --missing-edges $alpha \     # Remove $alpha edges from the quasi-clique
    --extra-edges 0 \            # Do not add any spurious edge
    --timeout 300                # Limit execution to 5 minutes
done
\end{minted}
\end{code}

On the other hand, snippet~\ref{script:quasi_spurious} shows the call used to evaluate
the capacity of \PresQ to recover from both missing and spurious edges, as reported in
figure~\ref{fig:hyper_ab_corr}. The set of spurious edges $S$ contains \emph{all} possible edges
on the hypergraph \emph{not} belonging to the quasi-clique.

\begin{code}
\caption{Benchmark quasi-clique search with a set of additional edges}\label{script:quasi_spurious}
\begin{minted}{bash}
for beta in 0.2 0.4 0.6 0.8; do
  ./bin/benchmark-quasiclique.py \
    --out results/quasi3.csv \ # Output CSV
    --rank 3 \                 # 3-hypergraph
    --cardinality 10 20 30 \   # Number of nodes on the quasi-clique
    --additional 0.5 \         # |V| * 0.5 additional nodes
    --repeat 15 \              # Generate 15 different hypergraphs
    --missing-edges 0.1 \      # Remove 10% of edges from the quasi-clique
    --extra-edges $beta \      # Add $beta * |S| spurious edges
    --timeout 1200             # Limit execution to 20 minutes
done
\end{minted}
\end{code}

\section{Bench-marking EDD finding}

\subsection{\Find vs. \PresQ}

\begin{code}
\label{script:edd_finding}
\caption{Benchmark \Find vs. \PresQ over the Ailerons/Elevators datasets}
\begin{minted}{bash}
ID="ailerons_$(date +%Y%m%d)"

./bin/benchmark.py --id "${ID}" \
    --repeat 1000 \
    --timeout 3000 \
    --output-dir "./results/" \
    "./data/keel/ailerons/ailerons.dat" \
    "./data/keel/elevators/elevators.dat"
\end{minted}
\end{code}

\subsection{Performance wrt. columns}

\begin{code}
\label{script:perf_columns}
\caption{Benchmark performance with respect to the number of columns}
\begin{minted}{bash}
ID="chembl_$(date +%Y%m%d)"

for i in {82..160..6}; do
    ./bin/benchmark.py --id "${ID}" \
        --output-dir "./results/" \
        --lambdas 0.1 \
        --bootstrap-alpha 0.05 \
        --no-find2 \
        --repeat 10 \
        --files $i \
        --timeout 3000 \
        ./data/chembl/chembl_??.db
done
\end{minted}
\end{code}
